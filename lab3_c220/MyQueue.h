#pragma once

template <typename T>
class MyQueue
{
	T* m_p{}; // указатель на начало динамического массива
	size_t m_n{}; // актуальное количество элементов в очереди
	size_t m_cap{ 1 }; // емкость (сколько выделено пам€ти)
	size_t m_first{}; // индекс первого элемента в очереди (это тот элемент, который можно извлечь из очереди с помощью pop())
	size_t m_last{}; // индекс первого свободного элемента в очереди (это тот элемент, в который можно присвоить новое значение с помощью push())
	const size_t delta{ 1 }; // на сколько увеличиваем емкость при перераспределении пам€ти
public:
	class iterator {
		// данные и методы, реализующие функциональность итератора дл€ кольцевой очереди
		const MyQueue* m_pQ; // итерируема€ очередь
		int m_i; // индекс текущего элемента
	public:
		iterator(Е) { Е }
		// реализуем методы, которые использует range-based for
		iterator& operator++ () { Е } // оператор префиксного инкремента
		T& operator* () { Е } // оператор разыменовани€
		bool operator!= (const iterator&) const { Е } // оператор сравнени€
		// может быть потребуетс€ что-то еще
	};
	iterator begin() const { . . . } // итератор на начало очереди
	iterator end() const { . . . } // итератор на конец очереди
	// так как класс сложный, реализуем Ђджентльменскийї набор:
	MyQueue();
	~MyQueue();
	MyQueue(const MyQueue&);
	MyQueue(MyQueue&&);
	MyQueue& operator= (const MyQueue&);
	MyQueue& operator= (MyQueue&&);
	Е
		// методы, реализующие функциональность очереди
		void push(Е);
	T pop();
	Е
		// а также, методы, необходимые дл€ выполнени€ задани€
};

